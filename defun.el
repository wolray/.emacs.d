(defmacro m-cycle-values (var values)
  `(let ((i (cl-position ,var ,values)))
     (setq ,var (elt ,values (if (and i (< (1+ i) (length ,values))) (1+ i) 0)))))

(defmacro m-map-key (obj key)
  `(let ((keystr (cadr ',key)) mapkey vmchar)
     (define-key key-translation-map ,key
       (if (not (symbolp ,obj)) ,obj
	 (setq mapkey (kbd (concat "M-g " keystr)))
	 (global-set-key mapkey ,obj) mapkey))
     (setq vmchar (substring keystr -1))
     (when (and (string= "C" (substring keystr 0 1))
		(string-match "[[:alnum:]`\\]" vmchar)
		(or (= 3 (length keystr))
		    (when (string= "S" (substring keystr 2 3))
		      (setq vmchar (upcase vmchar)) t)))
       (define-key visual-mode-map (kbd vmchar)
	 (if (symbolp ,obj) ,obj (key-binding ,obj))))))

(defun f-backward-kill-line ()
  (interactive)
  (kill-region (line-beginning-position) (point))
  (indent-for-tab-command))

(defun f-copy-buffer ()
  (interactive)
  (save-excursion
    (goto-char (point-max))
    (unless (or (eobp) buffer-read-only) (newline 1)))
  (delete-trailing-whitespace)
  (kill-ring-save (point-min) (point-max))
  (message "Current buffer copied"))

(defun f-cua-rectangle-mark-mode ()
  (interactive)
  (visual-mode -1)
  (call-interactively 'cua-rectangle-mark-mode))

(defun f-cua-sequence-rectangle (first incr fmt)
  (interactive
   (let ((seq (split-string
	       (read-string (concat "1 (+1) ("
				    (substring cua--rectangle-seq-format 1)
				    "): ") nil nil))))
     (list (string-to-number (or (car seq) "1"))
    	   (string-to-number (or (cadr seq) "1"))
	   (concat "%" (cadr (cdr seq))))))
  (if (string= fmt "%") (setq fmt cua--rectangle-seq-format)
    (setq cua--rectangle-seq-format fmt))
  (cua--rectangle-operation 'clear nil t 1 nil
			    (lambda (s e _l _r)
			      (delete-region s e)
			      (insert (format fmt first))
			      (setq first (+ first incr)))))

(defun f-cycle-paren-shapes ()
  (interactive)
  (save-excursion
    (unless (looking-at-p (rx (any "([")))
      (backward-up-list))
    (let ((pt (point))
	  (new (cond ((looking-at-p (rx "(")) (cons "[" "]"))
		     ((looking-at-p (rx "[")) (cons "(" ")"))
		     (t (beep) nil))))
      (when new
	(forward-sexp)
	(delete-char -1)
	(insert (cdr new))
	(goto-char pt)
	(delete-char 1)
	(insert (car new))))))

(defun f-cycle-search-whitespace-regexp ()
  (interactive)
  (m-cycle-values search-whitespace-regexp '("\\s-+" ".*?"))
  (message "search-whitespace-regexp: \"%s\"" search-whitespace-regexp))

(defun f-dired ()
  (interactive)
  (switch-to-buffer (dired-noselect default-directory))
  (revert-buffer))

(defun f-highlight-symbol ()
  (interactive)
  (visual-mode -1)
  (let ((s (highlight-symbol-get-symbol)))
    (if (or (not s) (highlight-symbol-symbol-highlighted-p s))
	(highlight-symbol-remove-all)
      (highlight-symbol)
      (visual-mode 1))))

(defun f-incf (&optional first incr repeat)
  (let ((index (floor (/ (cl-incf count 0) (or repeat 1)))))
    (+ (or first 1) (* (or incr 1) index))))
(defun f-each (ls &optional repeat)
  (let ((index (floor (/ (cl-incf count 0) (or repeat 1)))))
    (if (< index (length ls)) (elt ls index)
      (keyboard-quit))))

(defun f-indent-paragraph ()
  (interactive)
  (save-excursion
    (mark-paragraph)
    (indent-region (region-beginning) (region-end))))

(defun f-kill-region ()
  (interactive)
  (if (use-region-p)
      (kill-region (region-beginning) (region-end))
    (kill-whole-line 1)
    (back-to-indentation)))

(defun f-kill-ring-save ()
  (interactive)
  (if (use-region-p)
      (kill-ring-save (region-beginning) (region-end))
    (save-excursion
      (back-to-indentation)
      (skip-chars-forward v-skip-chars)
      (kill-ring-save (point) (line-end-position)))
    (unless (minibufferp) (message "Current line copied"))))

(defun f-kmacro-end-or-call-macro (arg)
  (interactive "P")
  (visual-mode -1)
  (cond ((minibufferp)
	 (if (eq last-command 'f-kmacro-end-or-call-macro) (insert "'()")
	   (insert "\\,(f-each )"))
	 (left-char 1))
	(defining-kbd-macro (kmacro-end-macro arg))
	((use-region-p)
	 (apply-macro-to-region-lines (region-beginning) (region-end)))
	(t (kmacro-call-macro arg t))))

(defun f-kmacro-start-macro (arg)
  (interactive "P")
  (visual-mode -1)
  (cond ((minibufferp)
	 (insert "\\,(f-incf)")
	 (left-char 1))
	(t (setq defining-kbd-macro nil)
	   (kmacro-start-macro arg))))

(defun f-kmacro-view-macro ()
  (interactive)
  (if (eq last-command 'kmacro-view-macro) (keyboard-quit)
    (kmacro-view-macro)))

(defun f-org-make-tdiff-string (diff)
  (let ((y (floor (/ diff 365))) (d (mod diff 365)) (fmt "") (l nil))
    (cond ((= diff 0) (setq fmt "today"))
	  ((< diff 0)
	   (if (< y 0) (setq fmt (concat fmt "%d year"  (if (< y -1) "s") " ")
			     l (push (- y) l)))
	   (setq fmt (concat fmt "%d day"  (if (< d 364) "s") " until")
		 l (push (- 365 d) l)))
	  ((> diff 0)
	   (if (> y 0) (setq fmt (concat fmt "%d year"  (if (> y 1) "s") " ")
			     l (push y l)))
	   (setq fmt (concat fmt "%d day"  (if (> d 1) "s") " since")
		 l (push d l))))
    (apply 'format fmt (nreverse l))))
(defun f-org-evaluate-time-range ()
  (interactive)
  (or
   (org-clock-update-time-maybe)
   (save-excursion
     (unless (org-at-timestamp-p)
       (beginning-of-line)
       (re-search-forward org-tsr-regexp (line-end-position) t))
     (unless (org-at-timestamp-p)
       (user-error "")))
   (let* ((ts1 (match-string 0))
	  (time1 (org-time-string-to-time ts1))
	  (t1 (time-to-days time1))
	  (t2 (time-to-days (current-time)))
	  (diff (- t2 t1)))
     (message "%s" (f-org-make-tdiff-string diff)))))

(defun f-other-window ()
  (interactive)
  (let ((vp visual-mode))
    (other-window 1)
    (when (and vp (cl-position major-mode
			       '(
				 emacs-lisp-mode
				 ess-mode
				 lisp-interaction-mode
				 matlab-mode
				 org-mode
				 python-mode
				 )))
      (visual-mode 1))))

(defun f-paragraph-backward ()
  (interactive)
  (unless (f-visual-mode-locked-p) (visual-mode 1))
  (if (not (eq major-mode 'org-mode))
	(backward-paragraph)
    (org-backward-element)
    (skip-chars-forward v-skip-chars)))

(defun f-paragraph-forward ()
  (interactive)
  (unless (f-visual-mode-locked-p) (visual-mode 1))
  (if (not (eq major-mode 'org-mode))
	(forward-paragraph)
    (org-forward-element)
    (skip-chars-forward v-skip-chars)))

(defun f-paragraph-set ()
  (setq paragraph-start "\f\\|[ \t]*$"
	paragraph-separate "[ \t\f]*$"))

(defun f-python-shell-send-line ()
  (interactive)
  (python-shell-send-region
   (line-beginning-position) (line-end-position)))

(defun f-query-replace ()
  (interactive)
  (unless (minibufferp)
    (if (highlight-symbol-symbol-highlighted-p
	 (highlight-symbol-get-symbol))
	(call-interactively 'highlight-symbol-query-replace)
      (call-interactively 'query-replace))))

(defun f-query-replace-regexp ()
  (interactive)
  (unless (minibufferp) (call-interactively 'query-replace-regexp)))

(defun f-racket-send-buffer ()
  (interactive)
  (set-mark (point))
  (racket-send-region
   (point-min) (point-max)))

(defun f-revert-buffer ()
  (interactive)
  (if (minibufferp) (kill-whole-line)
    (when (buffer-modified-p) (revert-buffer t t))))

(defun f-set-or-exchange-mark (arg)
  (interactive "P")
  (if (use-region-p) (exchange-point-and-mark)
    (set-mark-command arg)))

(defun f-shell-clear ()
  (if (not (get-buffer-process (current-buffer)))
      (message "No inferior process")
    (delete-region (point-min) (point-max))
    (comint-send-input)
    (goto-char (point-min))
    (kill-line)))

(defun f-shell-clear-shell ()
  (interactive)
  (let ((modes '(python-mode ess-mode)) (buffers '("*Python*" "*R*")) i)
    (setq i (cl-position major-mode modes))
    (if i (with-temp-buffer
	    (switch-to-buffer (elt buffers i))
	    (f-shell-clear)
	    (switch-to-prev-buffer))
      (f-shell-clear))))

(defun f-sort-lines ()
  (interactive)
  (when (use-region-p)
    (sort-lines nil (region-beginning) (region-end))))

(defun f-sort-paragraphs ()
  (interactive)
  (sort-paragraphs nil (point-min) (point-max))
  (message "All paragraphs sorted"))

(defun f-switch-to-scratch ()
  (interactive)
  (switch-to-buffer "*scratch*"))

(defun f-toggle-comment (beg end)
  (interactive
   (if (use-region-p) (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-beginning-position 2))))
  (comment-or-uncomment-region beg end))

(defun f-transpose-lines-down ()
  (interactive)
  (end-of-line)
  (unless (eobp)
    (forward-line 1)
    (unless (eobp)
      (transpose-lines 1)
      (forward-line -1)
      (end-of-line))))

(defun f-transpose-lines-up ()
  (interactive)
  (beginning-of-line)
  (unless (or (bobp) (eobp))
    (forward-line 1)
    (transpose-lines -1)
    (beginning-of-line -1))
  (skip-chars-forward v-skip-chars))

(defun f-transpose-paragraphs-down ()
  (interactive)
  (backward-paragraph)
  (forward-paragraph)
  (unless (eobp) (transpose-paragraphs 1)))

(defun f-transpose-paragraphs-up ()
  (interactive)
  (backward-paragraph)
  (forward-paragraph)
  (unless (bobp)
    (transpose-paragraphs -1)
    (backward-paragraph)))

(defun f-visual-mode-locked-p ()
  (or visual-mode
      (minibufferp)
      defining-kbd-macro
      executing-kbd-macro
      ))

(defun f-visual-mode-off ()
  (interactive)
  (visual-mode -1))

(defun f-word-capitalize ()
  (interactive)
  (capitalize-word -1))

(defun f-word-downcase ()
  (interactive)
  (downcase-word -1))

(defun f-word-upcase ()
  (interactive)
  (upcase-word -1))

(defvar v-frame 100)
(defun f-toggle-v-frame ()
  (interactive)
  (m-cycle-values v-frame '(100 70))
  (set-frame-parameter (selected-frame) 'alpha v-frame))

(defvar v-page 10)
(make-variable-buffer-local 'v-page)
(defun f-toggle-v-page ()
  (interactive)
  (m-cycle-values v-page '(10 20 50))
  (message "v-page: %s" v-page))
(defun f-page-up ()
  (interactive)
  (beginning-of-line (- (1- v-page))))
(defun f-page-down ()
  (interactive)
  (beginning-of-line (1+ v-page)))

(defvar v-skip-chars " \t")
(make-variable-buffer-local 'v-skip-chars)
(defun f-move-up-line ()
  (interactive)
  (if (minibufferp) (beginning-of-line)
    (skip-chars-backward v-skip-chars)
    (beginning-of-line (if (bolp) 0 1))
    (skip-chars-forward v-skip-chars)
    (unless (f-visual-mode-locked-p) (visual-mode 1))))
(defun f-move-up-line-beginning ()
  (interactive)
  (if (not (eq major-mode 'org-mode))
      (beginning-of-line (if (bolp) 0 1))
    (org-up-element)
    (skip-chars-forward v-skip-chars))
  (unless (f-visual-mode-locked-p) (visual-mode 1)))
(defun f-move-down-line ()
  (interactive)
  (if (minibufferp) (end-of-line)
    (save-excursion
      (end-of-line)
      (when (and (eobp) (not buffer-read-only)) (newline 1)))
    (skip-chars-backward v-skip-chars)
    (beginning-of-line 2)
    (skip-chars-forward v-skip-chars)
    (unless (f-visual-mode-locked-p) (visual-mode 1))))
(defun f-move-down-line-end ()
  (interactive)
  (end-of-line (if (eolp) 2 1))
  (unless (f-visual-mode-locked-p) (visual-mode 1)))
